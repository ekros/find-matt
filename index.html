<html>
<head>
<script src="https://js13kgames.com/webxr-src/2020/three.js"></script>
<style>
    body { margin: 0; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script src="VRButton.js"></script>
  <script src="PickHelper.js"></script>
  <script src="MessageBox.js"></script>
  <script src="Enemy.js"></script>
  <script type="module">
        let tick = 0;
  			let camera, scene, renderer, material;
        let mouseX = 0, mouseY = 0;
        const systems = [];

        // game states
        const GAME_STATES = {
          IDLE: 0,
          SCANNING: 1,
          PAUSED: 2
        };

        // game progress
        const GAME_PROGRESS = {
          FOLLOW_MATT_ITINERARY: 0,
          FIND_FIRST_BEACON: 1,
          MEET_THE_PLAGUE: 2,
          FIND_SECOND_BEACON: 3,
          FIND_THIRD_BEACON: 4,
          CROSS_PLAGUE_TERRITORY: 5,
          ANCIENT_CIV: 6,
          WORM_HOLE: 7,
          END: 8
        };
        let gameProgress = GAME_PROGRESS.FIND_THIRD_BEACON;
        let gameState;
        let currentQuestCompleted = false;
        let scansBeforeNextEvent; // systems the player needs to scan before the next event

        // starship
        let starship;
        let starshipDirection;
        let speed = 0;
        const accel = 0.003;
        const topSpeed = 1;
        let destinationObject;
        let distanceToDestination;
        let orbitingSystemId;

        let enemies = [];

        // picking and targets
        let pickHelper;
        let selectedObject;
        let target; // ex: hint about the next system to visit
        let lockSelection; // blocks continuous selection of focused target
        let enableSelection = true;
        let searchAreaCenter; // the center of the next search area

        let message;
        let scanProgress = 0;


  			init();
  			animate();

  			function init() {

  				scene = new THREE.Scene();
          scene.fog = new THREE.FogExp2( 0x000000, 0.001 );


          // our starship
          starship = new THREE.Object3D();
          scene.add(starship);

  				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 2000 );
  				// camera.position.set( 0, 1.6, 1000 );
          starship.position.set(0, 1.6, 0);
          starship.add(camera);

          message = new MessageBox(scene, camera, starship.position);

          pickHelper = new PickHelper(camera);
          // our pointer
          // var geometry = new THREE.BufferGeometry();
          // var sprite = new THREE.TextureLoader().load( 'sprites/disc.png' );
          // material = new THREE.PointsMaterial( { size: 1, sizeAttenuation: true, alphaTest: 0.5, transparent: false } );
          // material.color.setHSL( 1.0, 0.3, 0.7 );
          //
          // pointer = new THREE.Points( geometry, material );
          // pointer.
          // camera.add(pointer);

  				//

          // var geometry = new THREE.BufferGeometry();

          // var sprite = new THREE.TextureLoader().load( 'sprites/disc.png' );

          // let vectors = [];

          for ( var i = 0; i < 5000; i ++ ) {

            var x = 4000 * Math.random() - 2000;
            var y = 4000 * Math.random() - 2000;
            var z = 4000 * Math.random() - 2000;


            // vectors.push( x, y, z );
            // systems.push({ vector: { x, y, z }, id: i, mattIsHere })

            const geometry = new THREE.CircleGeometry( 10, 32 );
            const material = new THREE.MeshBasicMaterial();
            const circle = new THREE.Mesh( geometry, material );
            circle.position.x = x;
            circle.position.y = y;
            circle.position.z = z;
            circle.kind = "system";
            circle.systemId = i;
            circle.lookAt(starship.position);
            scene.add( circle );
          }


          // geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vectors, 3 ) );
          //
          //
          // console.log("systems", systems);
          //
          // material = new THREE.PointsMaterial( { size: 25, sizeAttenuation: true, map: sprite, alphaTest: 0.5, transparent: true } );
          // material.color.setHSL( 0.5, 1, 0.5 );
          //
          // var particles = new THREE.Points( geometry, material );
          // scene.add( particles );

          //

          renderer = new THREE.WebGLRenderer();
          renderer.setPixelRatio( window.devicePixelRatio );
          renderer.setSize( window.innerWidth, window.innerHeight );
          renderer.xr.enabled = true;
          // renderer.xr.setReferenceSpaceType( 'local' );
          document.body.appendChild( renderer.domElement );
          document.body.appendChild(VRButton.createButton(renderer));

  				//

  				window.addEventListener( 'resize', onWindowResize, false );

  				//

  				if ( typeof TESTING !== 'undefined'  ) { for ( var i = 0; i < 200; i ++ ) { render(); } };

  			}

  			function onWindowResize() {

  				camera.aspect = window.innerWidth / window.innerHeight;
  				camera.updateProjectionMatrix();

  				renderer.setSize( window.innerWidth, window.innerHeight );

  			}

  			function animate() {

  				renderer.setAnimationLoop( render );

          render();
  			}

        // system statuses

        function setVisited(system) {
          system.material.color.setHSL( 0.4, 1, 0.7 );
          system.isVisited = true;
        }
        function setSystemInSearchArea(system, hsl) {
          const h = hsl && hsl[0] || 0.2;
          const s = hsl && hsl[1] || 0.9;
          const l = hsl && hsl[2] || 0.6;
          system.material.color.setHSL( h, s, l );
          system.inSearchArea = true;
        }
        function setSystemInDangerArea(system, hsl) {
          const h = hsl && hsl[0] || 1;
          const s = hsl && hsl[1] || 0.5;
          const l = hsl && hsl[2] || 0.5;
          system.material.color.setHSL( h, s, l );
          system.inDangerArea = true;
        }
        function unsetSystemInSearchArea(system) {
          system.material.color.setHSL( 0, 0, 1 );
          system.inSearchArea = false;
        }
        function unsetSystemInDangerArea(system) {
          system.material.color.setHSL( 0, 0, 1 );
          system.inDangerArea = false;
        }

        function goTo(selectedObject) {
          speed = 0.1;
          starshipDirection = new THREE.Vector3(selectedObject.position.x - starship.position.x,
            selectedObject.position.y - starship.position.y,
            selectedObject.position.z - starship.position.z);
          starshipDirection = starshipDirection.normalize();
          destinationObject = selectedObject;
        }

        function scanSystem(system) {
          gameState = GAME_STATES.SCANNING;
          console.log("starship", starship.position);
          message = new MessageBox(scene, camera, starship.position);
        }

        function getAllSystems() {
          return scene.children.filter(obj => obj.kind === "system");
        }

        function getNearSystems(center, distance) {
          const v1 = new THREE.Vector3(center.x, center.y, center.z);
          const systems = getAllSystems();
          const nearSystems = [];
          systems.forEach(s => {
            const d = v1.distanceTo(new THREE.Vector3(s.position.x, s.position.y, s.position.z));
            if (d <= distance) {
              nearSystems.push(s);
            }
          });
          return nearSystems;
        }

        function getRandomSystemInFront(distance) {
          // set default position in front of the camera
          const raycaster = new THREE.Raycaster();
          // cast a ray through the frustum
          raycaster.setFromCamera({ x: 0, y: 0 }, camera);
          let t = new THREE.Vector3();
          raycaster.ray.at(distance ? (distance - 100) : 400, t);
          // get near systems
          const nearSystems = getNearSystems(starship.position, distance || 500);
          let nearFrontSystem = nearSystems[0];
          let lastDistance;
          nearSystems.forEach(s => {
            const d = t.distanceTo(new THREE.Vector3(s.position.x, s.position.y, s.position.z));
            if (lastDistance && d < lastDistance) {
              nearFrontSystem = s;
            }
            lastDistance = d;
          });
          return nearFrontSystem;
        }

        function attachTargetSprite(target) {
          const geometry = new THREE.RingGeometry( 20, 22, 32 );
          const material = new THREE.MeshBasicMaterial( { color: 0xffff00, side: THREE.DoubleSide } );
          const ring = new THREE.Mesh( geometry, material );
          target.add( ring );
        }

        function setDangerArea(center, radius, hsl) {
          const nearSystems = getNearSystems(center, radius);
          nearSystems.forEach(s => {
            setSystemInDangerArea(s, hsl);
          });
        }

        function setSearchArea(center, radius, hsl) {
          const nearSystems = getNearSystems(center, radius);
          nearSystems.forEach(s => {
            setSystemInSearchArea(s, hsl);
          });
        }

        function clearSearchArea() {
          const allSystems = getAllSystems();
          allSystems.forEach(s => {
            unsetSystemInSearchArea(s);
          });
          searchAreaCenter = undefined;
        }

        function addRandomEnemy() {
          const randomNearSystem = getNearSystems(starship.position, 500)[0];
          const enemy = new Enemy(randomNearSystem, scene, starship.position);
        }

  			function render() {
          let time = Date.now() * 0.00005;

  				// camera.position.x += ( mouseX - camera.position.x ) * 0.05;
  				// camera.position.y += ( - mouseY - camera.position.y ) * 0.05;

          switch(gameProgress) {
            case GAME_PROGRESS.FOLLOW_MATT_ITINERARY:
              if (gameState !== GAME_STATES.PAUSED) {
                gameState = GAME_STATES.PAUSED;
                message.render(["Matt left our planet years ago...\nHe was looking for a new home...\nBefore it's too late.",
                "I marked in the map where he is supposed to be. Just look there."]);
                gameProgress += 1;
              }
            break;
            case GAME_PROGRESS.FIND_FIRST_BEACON:
              if (!target) {
                target = getRandomSystemInFront();
                target.isNextTarget = true;
                attachTargetSprite(target);
              } else if (currentQuestCompleted) {
                gameState = GAME_STATES.PAUSED;
                message.render(["I've detected a signal...\nIt's a beacon...", "...but it doesn't contain any message.\nWhy?", "And where is Matt?\nOur new home is here...\nBut, wait.", "It has been devastated.\nThe Plague did this.\nI'm sure.", "If they are here, our home planet\nwill be destroyed within months,\nmaybe weeks.", "I must evade their ships, or I'm dead.", "I can calculate Matt's route\nbased on the beacon orientation.\n", "It's a risky guess\n but it's the only thing I have", "I only need to check\nthe dozens of systems\nin that sector.\nGood luck Amy..."]);
                currentQuestCompleted = false;
                gameProgress += 1;
                target.isNextTarget = false;
                setVisited(target);
                target = undefined;
                // TODO: remove the target ring
              }
            break;
            case GAME_PROGRESS.MEET_THE_PLAGUE:
              if (!searchAreaCenter) {
                scansBeforeNextEvent = 2;
                searchAreaCenter = getRandomSystemInFront(1300);
                setSearchArea(searchAreaCenter.position, 400);
              }

              // message = new MessageBox(scene, camera, starship.position); // remove
              if (currentQuestCompleted) {
                console.log("MEET THE PLAGUE COMPLETED");
                gameState = GAME_STATES.PAUSED;
                message.render(["I'm not alone in this sector\nI detect a near starship...", "The Plague is here!", "I marked its position on the map\nso I remember to stay away\n from them."]);
                addRandomEnemy();
                currentQuestCompleted = false;
                gameProgress += 1;
                scansBeforeNextEvent = 1;
              }
            break;
            case GAME_PROGRESS.FIND_SECOND_BEACON:
              if (currentQuestCompleted) {
                gameState = GAME_STATES.PAUSED;
                message.render(["It's my lucky day!\nI found another beacon!", "Matt is OK, and he\nis looking for exotic matter\nto power his starship.", "It can be found scanning singularities.\nI need it to travel through\ninterestellar space.", "His ship's navigation system\nseems to be broken\nso I can only make aproximate\ncalculations about his route."]);
                currentQuestCompleted = false;
                gameProgress += 1;
                clearSearchArea();
              }
            break;
            case GAME_PROGRESS.FIND_THIRD_BEACON:
              if (!searchAreaCenter) {
                scansBeforeNextEvent = 2;
                searchAreaCenter = getRandomSystemInFront(1000);
                setSearchArea(searchAreaCenter.position, 500);
              }
              currentQuestCompleted = true; // TODO: remove this. Just a bypass for now
              if (currentQuestCompleted) {
                console.log("FIND THIRD BEACON COMPLETED");
                gameState = GAME_STATES.PAUSED;
                message.render(["Bad news...", "His navigation system seems definitively broken", "He is heading to The Plague territory!", "I need to arrive to the\ndestination sector without\nbeing discovered."]);
                currentQuestCompleted = false;
                gameProgress += 1;
                clearSearchArea();
              }
            break;
            case GAME_PROGRESS.CROSS_PLAGUE_TERRITORY:
            if (!searchAreaCenter) {
              addRandomEnemy(); // TODO: add multiple enemies here
              scansBeforeNextEvent = 2;
              searchAreaCenter = getRandomSystemInFront(700);
              setDangerArea(searchAreaCenter.position, 500);
              searchAreaCenter = getRandomSystemInFront(1600);
              setSearchArea(searchAreaCenter.position, 400);
            }
            break;
            case GAME_PROGRESS.ANCIENT_CIV:
            break;
            case GAME_PROGRESS.WORM_HOLE:
            break;
            case GAME_PROGRESS.END:
            break;
            default:
            break;
          }
          // move starship forward
          if (speed > 0) {
            // let direction = new THREE.Vector3(0, 0, 0);
            // camera.getWorldDirection(direction);
            starship.position.x += starshipDirection.x * speed;
            starship.position.y += starshipDirection.y * speed;
            starship.position.z += starshipDirection.z * speed;


            // acceleration and slow down
            if (distanceToDestination && distanceToDestination < 250) {
              speed -= accel * 2;
            } else if (speed < topSpeed) {
              speed += accel;
            }

            if (speed < 0 || distanceToDestination < 50) { // just in case
              speed = 0;
              orbitingSystemId = destinationObject.systemId;
              scanSystem(destinationObject);
            }

            // update distance every 10 ticks
            if (tick % 10 === 0) {
              console.log("speed", speed);
              distanceToDestination = Math.sqrt(Math.pow(destinationObject.position.x - starship.position.x, 2) +
              Math.pow(destinationObject.position.y - starship.position.y, 2) +
              Math.pow(destinationObject.position.z - starship.position.z, 2));
              console.log("Remaining distance", distanceToDestination);
            }

            // rotate systems to look the starship
            const systems = getAllSystems();
            systems.forEach(system => {
              system.lookAt(starship.position);
            });
          }

          // scanning
          if (gameState === GAME_STATES.SCANNING) {
            scanProgress += 0.5;
            message.render(`SCANNING...${scanProgress.toFixed(0)}%`);
            if (scanProgress >= 100) {
              message.reset();
              gameState = GAME_STATES.IDLE;
              scanProgress = 0;
              // let's reveal what is in this system
              if (!destinationObject.isNextTarget) {
                // TODO: you could collect items if any
                console.log("[1] scansBeforeNextEvent", scansBeforeNextEvent);
                setVisited(destinationObject);
                if (destinationObject.inSearchArea && scansBeforeNextEvent > 0) {
                  scansBeforeNextEvent -= 1;
                  console.log("[2] scansBeforeNextEvent", scansBeforeNextEvent);
                  if (scansBeforeNextEvent === 0) {
                    currentQuestCompleted = true; // trigger next event in the timeline
                  }
                }
                if (!destinationObject.inSearchArea || (destinationObject.inSearchArea && scansBeforeNextEvent > 0)) {
                  message.render("Nothing found");
                  setTimeout(() => {
                    message.destroy();
                  }, 2000);
                }
              } else {
                message.reset();
                currentQuestCompleted = true;
              }
            }
          }

          // pick objects
          selectedObject = pickHelper.pick({x: 0, y: 0}, scene, camera, time);
          // if (!selectedObject && lockSelection) {
          //   enableSelection = true;
          // }
          // console.log("selectedObject", selectedObject);
          if (!lockSelection) {

            console.group("1");
            console.log("selectedObject", selectedObject);
            console.log("gameState", gameState);
            console.groupEnd("1");
          }
          if (selectedObject && speed === 0 && selectedObject.systemId !== orbitingSystemId &&
            gameState !== GAME_STATES.PAUSED && selectedObject.kind === "system" && !selectedObject.isVisited) {

            // console.log(selectedObject)
            selectedObject.material.color.setHSL( 0.7, 1, 0.8 );
            goTo(selectedObject);
          } else if (selectedObject && gameState === GAME_STATES.PAUSED && selectedObject.kind === "message" && !lockSelection) {
            console.log("autoNext");
            message.autoNext()
            .then(() => {
              console.log("finish yeeeeeaaahhh!");
              gameState = GAME_STATES.IDLE;
            });
            // console.log("lockSelection", lockSelection);
            // if (!lockSelection && !message.next()) {
            //   gameProgress += 1;
            //   gameState = GAME_STATES.IDLE;
            // }
          }
          if (selectedObject) {
            lockSelection = true;
            // enableSelection = false;
          } else {
            lockSelection = false;
            console.log("lockSelection", lockSelection);
          }
  				// starship.lookAt( scene.position );

  				// var h = ( 360 * ( 1.0 + time ) % 360 ) / 360;
  				// material.color.setHSL( h, 0.5, 0.5 );

  				renderer.render( scene, camera );
          tick += 1;
  			}
      </script>
</body>
</html>

<!-- class MouseControl {
constructor(camera, instanceId, sensitivity = 4) {
  console.log(`%c${instanceId}`, "background:green;color:white;");
  console.log(`%c${camera}`, "background:blue;color:white;");
  this.instanceId = instanceId;
  this.camera = camera;
  this.sensitivity = sensitivity;

  console.log("camera", camera);
  this.lookAt = {x: 0, y: 0, z: 0};
  this.mouseX = 0;
  this.mouseY = 0;
  this.previousDirection = {
    x: 0,
    y: 0,
    z: 0
  };
  document.addEventListener("mousedown", this.handleMouseDown);
}

handleMouseDown = ev => {
  // console.log("mousedown", this.camera.rotation);
  document.addEventListener("mousemove", this.handleMouseMove);
  document.addEventListener("mouseup", this.handleMouseUp);
  document.body.style.cursor = "grabbing";
  this.mouseX = 0;
  this.mouseY = 0;
}

handleMouseUp = ev => {
  console.log("mouseup", this.instanceId);
  document.removeEventListener("mousemove", this.handleMouseMove);
  document.removeEventListener("mouseup", this.handleMouseUp);
  document.body.style.cursor = "default";
  this.previousDirection = {
    x: 0,
    y: 0,
    z: 0
  }
}

handleMouseMove = ev => { // TODO: camera direction is being set using absolute position, not relative.
  // this.camera.lookAt(this.camera.rotation.x, this.camera.rotation.y, this.camera.rotation.z + 0.01);
  // const deltaX = ev.pageX - this.mouseX;
  // const deltaY = ev.pageY - this.mouseY;
  // console.log("x", deltaX);
  // console.log("y", deltaY);


  const direction = this.getDirection(ev);
  this.lookAt.x += (direction.x - this.previousDirection.x) * this.sensitivity;
  this.lookAt.y += (direction.y - this.previousDirection.y) * this.sensitivity;
  this.lookAt.z += (direction.z - this.previousDirection.z) * this.sensitivity;

  this.previousDirection = direction;

  // this.lookAt.x += deltaX * 0.005;
  // this.lookAt.y += deltaY * 0.005;

  // this.lookAt.x += ev.pageX - (window.innerWidth / 2);
  // this.lookAt.y += ev.pageY - (window.innerHeight / 2);

  // save current pos
  this.mouseX = ev.pageX;
  this.mouseY = ev.pageY;
}

getDirection = evt => {
  let direction = new THREE.Vector3();
  let mouse = new THREE.Vector2();
  let origin = new THREE.Vector3();
  let rayCasterConfig = {origin: origin, direction: direction};

  let bounds = document.body.getBoundingClientRect();
  // let camera = this.camera;
  let left;
  let point;
  let top;

  this.camera.parent && this.camera.parent.updateMatrixWorld();

  // Calculate mouse position based on the canvas element
  if (evt.type === 'touchmove' || evt.type === 'touchstart') {
    // Track the first touch for simplicity.
    point = evt.touches.item(0);
  } else {
    point = evt;
  }

  left = point.clientX - bounds.left;
  top = point.clientY - bounds.top;
  mouse.x = (left / bounds.width) * 2 - 1;
  mouse.y = -(top / bounds.height) * 2 + 1;

  origin.setFromMatrixPosition(this.camera.matrixWorld);
  direction.set(mouse.x, mouse.y, 0.5).unproject(this.camera).sub(origin).normalize();
  return direction;
  // this.el.setAttribute('raycaster', rayCasterConfig);
  // if (evt.type === 'touchmove') { evt.preventDefault(); }
}

update(camera) {
  this.camera = camera;
}

destroy() {
  document.removeEventListener("mousedown", this.handleMouseDown);
  delete this;
}
} -->
